{"ast":null,"code":"import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n  var _a;\n  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options);\n    node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n    return true;\n  }\n  return false;\n}\nasync function embedBackground(clonedNode, options) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options);\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options);\n  }\n}\nasync function embedImageNode(clonedNode, options) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {\n    return;\n  }\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve;\n    clonedNode.onerror = reject;\n    const image = clonedNode;\n    if (image.decode) {\n      image.decode = resolve;\n    }\n    if (image.loading === 'lazy') {\n      image.loading = 'eager';\n    }\n    if (isImageElement) {\n      clonedNode.srcset = '';\n      clonedNode.src = dataURL;\n    } else {\n      clonedNode.href.baseVal = dataURL;\n    }\n  });\n}\nasync function embedChildren(clonedNode, options) {\n  const children = toArray(clonedNode.childNodes);\n  const deferreds = children.map(child => embedImages(child, options));\n  await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options);\n    await embedImageNode(clonedNode, options);\n    await embedChildren(clonedNode, options);\n  }\n}","map":{"version":3,"names":["embedResources","toArray","isInstanceOfElement","isDataUrl","resourceToDataURL","getMimeType","embedProp","propName","node","options","propValue","_a","style","getPropertyValue","cssString","setProperty","getPropertyPriority","embedBackground","clonedNode","embedImageNode","isImageElement","HTMLImageElement","src","SVGImageElement","href","baseVal","url","dataURL","Promise","resolve","reject","onload","onerror","image","decode","loading","srcset","embedChildren","children","childNodes","deferreds","map","child","embedImages","all","then","Element"],"sources":["C:\\Users\\nguye\\receipt-app\\node_modules\\html-to-image\\src\\embed-images.ts"],"sourcesContent":["import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}