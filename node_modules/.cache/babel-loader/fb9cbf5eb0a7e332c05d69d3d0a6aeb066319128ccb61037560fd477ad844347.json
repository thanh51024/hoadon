{"ast":null,"code":"import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n  const dataURL = canvas.toDataURL();\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false);\n  }\n  return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.width = video.clientWidth;\n    canvas.height = video.clientHeight;\n    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n    const dataURL = canvas.toDataURL();\n    return createImage(dataURL);\n  }\n  const poster = video.poster;\n  const contentType = getMimeType(poster);\n  const dataURL = await resourceToDataURL(poster, contentType, options);\n  return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe) {\n  var _a;\n  try {\n    if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n      return await cloneNode(iframe.contentDocument.body, {}, true);\n    }\n  } catch (_b) {\n    // Failed to clone iframe\n  }\n  return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node);\n  }\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options);\n  }\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node);\n  }\n  return node.cloneNode(false);\n}\nconst isSlotElement = node => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n  var _a, _b;\n  let children = [];\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray(nativeNode.assignedNodes());\n  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n    children = toArray(nativeNode.contentDocument.body.childNodes);\n  } else {\n    children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n  }\n  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n    return clonedNode;\n  }\n  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then(clonedChild => {\n    if (clonedChild) {\n      clonedNode.appendChild(clonedChild);\n    }\n  }), Promise.resolve());\n  return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n  const targetStyle = clonedNode.style;\n  if (!targetStyle) {\n    return;\n  }\n  const sourceStyle = window.getComputedStyle(nativeNode);\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText;\n    targetStyle.transformOrigin = sourceStyle.transformOrigin;\n  } else {\n    toArray(sourceStyle).forEach(name => {\n      let value = sourceStyle.getPropertyValue(name);\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n        value = `${reducedFont}px`;\n      }\n      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === 'display' && value === 'inline') {\n        value = 'block';\n      }\n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`;\n      }\n      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n    });\n  }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value;\n  }\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value);\n  }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode;\n    const selectedOption = Array.from(clonedSelect.children).find(child => nativeNode.value === child.getAttribute('value'));\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '');\n    }\n  }\n}\nfunction decorate(nativeNode, clonedNode) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode);\n    clonePseudoElements(nativeNode, clonedNode);\n    cloneInputValue(nativeNode, clonedNode);\n    cloneSelectValue(nativeNode, clonedNode);\n  }\n  return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n  if (uses.length === 0) {\n    return clone;\n  }\n  const processedDefs = {};\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i];\n    const id = use.getAttribute('xlink:href');\n    if (id) {\n      const exist = clone.querySelector(id);\n      const definition = document.querySelector(id);\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = await cloneNode(definition, options, true);\n      }\n    }\n  }\n  const nodes = Object.values(processedDefs);\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml';\n    const svg = document.createElementNS(ns, 'svg');\n    svg.setAttribute('xmlns', ns);\n    svg.style.position = 'absolute';\n    svg.style.width = '0';\n    svg.style.height = '0';\n    svg.style.overflow = 'hidden';\n    svg.style.display = 'none';\n    const defs = document.createElementNS(ns, 'defs');\n    svg.appendChild(defs);\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i]);\n    }\n    clone.appendChild(svg);\n  }\n  return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null;\n  }\n  return Promise.resolve(node).then(clonedNode => cloneSingleNode(clonedNode, options)).then(clonedNode => cloneChildren(node, clonedNode, options)).then(clonedNode => decorate(node, clonedNode)).then(clonedNode => ensureSVGSymbols(clonedNode, options));\n}","map":{"version":3,"names":["clonePseudoElements","createImage","toArray","isInstanceOfElement","getMimeType","resourceToDataURL","cloneCanvasElement","canvas","dataURL","toDataURL","cloneNode","cloneVideoElement","video","options","currentSrc","document","createElement","ctx","getContext","width","clientWidth","height","clientHeight","drawImage","poster","contentType","cloneIFrameElement","iframe","_a","contentDocument","body","_b","cloneSingleNode","node","HTMLCanvasElement","HTMLVideoElement","HTMLIFrameElement","isSlotElement","tagName","toUpperCase","cloneChildren","nativeNode","clonedNode","children","assignedNodes","childNodes","shadowRoot","length","reduce","deferred","child","then","clonedChild","appendChild","Promise","resolve","cloneCSSStyle","targetStyle","style","sourceStyle","window","getComputedStyle","cssText","transformOrigin","forEach","name","value","getPropertyValue","endsWith","reducedFont","Math","floor","parseFloat","substring","getAttribute","setProperty","getPropertyPriority","cloneInputValue","HTMLTextAreaElement","innerHTML","HTMLInputElement","setAttribute","cloneSelectValue","HTMLSelectElement","clonedSelect","selectedOption","Array","from","find","decorate","Element","ensureSVGSymbols","clone","uses","querySelectorAll","processedDefs","i","use","id","exist","querySelector","definition","nodes","Object","values","ns","svg","createElementNS","position","overflow","display","defs","isRoot","filter"],"sources":["C:\\Users\\nguye\\receipt-app\\node_modules\\html-to-image\\src\\clone-node.ts"],"sourcesContent":["import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}