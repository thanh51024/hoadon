{"ast":null,"code":"import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n  const urls = [];\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url);\n    return raw;\n  });\n  return urls.filter(url => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    const contentType = getMimeType(resourceURL);\n    let dataURL;\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL);\n      dataURL = makeDataUrl(content, contentType);\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n  } catch (error) {\n    // pass\n  }\n  return cssText;\n}\nfunction filterPreferredFontFormat(str, _ref) {\n  let {\n    preferredFontFormat\n  } = _ref;\n  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, match => {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const [src,, format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n      if (!format) {\n        return '';\n      }\n      if (format === preferredFontFormat) {\n        return `src: ${src};`;\n      }\n    }\n  });\n}\nexport function shouldEmbed(url) {\n  return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n  if (!shouldEmbed(cssText)) {\n    return cssText;\n  }\n  const filteredCSSText = filterPreferredFontFormat(cssText, options);\n  const urls = parseURLs(filteredCSSText);\n  return urls.reduce((deferred, url) => deferred.then(css => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}","map":{"version":3,"names":["resolveUrl","getMimeType","isDataUrl","makeDataUrl","resourceToDataURL","URL_REGEX","URL_WITH_FORMAT_REGEX","FONT_SRC_REGEX","toRegex","url","escaped","replace","RegExp","parseURLs","cssText","urls","raw","quotation","push","filter","embed","resourceURL","baseURL","options","getContentFromUrl","resolvedURL","contentType","dataURL","content","error","filterPreferredFontFormat","str","_ref","preferredFontFormat","match","src","format","exec","shouldEmbed","search","embedResources","baseUrl","filteredCSSText","reduce","deferred","then","css","Promise","resolve"],"sources":["C:\\Users\\nguye\\receipt-app\\node_modules\\html-to-image\\src\\embed-resources.ts"],"sourcesContent":["import { Options } from './types'\nimport { resolveUrl } from './util'\nimport { getMimeType } from './mimes'\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\n\nfunction toRegex(url: string): RegExp {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\n}\n\nexport function parseURLs(cssText: string): string[] {\n  const urls: string[] = []\n\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url)\n    return raw\n  })\n\n  return urls.filter((url) => !isDataUrl(url))\n}\n\nexport async function embed(\n  cssText: string,\n  resourceURL: string,\n  baseURL: string | null,\n  options: Options,\n  getContentFromUrl?: (url: string) => Promise<string>,\n): Promise<string> {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\n    const contentType = getMimeType(resourceURL)\n    let dataURL: string\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL)\n      dataURL = makeDataUrl(content, contentType)\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\n  } catch (error) {\n    // pass\n  }\n  return cssText\n}\n\nfunction filterPreferredFontFormat(\n  str: string,\n  { preferredFontFormat }: Options,\n): string {\n  return !preferredFontFormat\n    ? str\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\n          if (!format) {\n            return ''\n          }\n\n          if (format === preferredFontFormat) {\n            return `src: ${src};`\n          }\n        }\n      })\n}\n\nexport function shouldEmbed(url: string): boolean {\n  return url.search(URL_REGEX) !== -1\n}\n\nexport async function embedResources(\n  cssText: string,\n  baseUrl: string | null,\n  options: Options,\n): Promise<string> {\n  if (!shouldEmbed(cssText)) {\n    return cssText\n  }\n\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\n  const urls = parseURLs(filteredCSSText)\n  return urls.reduce(\n    (deferred, url) =>\n      deferred.then((css) => embed(css, url, baseUrl, options)),\n    Promise.resolve(filteredCSSText),\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}